# 토픽 생성

> 상태를 관리하는 엔티티 단위로 생성하자

토픽은 폴더에 많이 비유되기는 하지만, 사실 폴더 그 이상의 의미를 가지고 있다. 폴더는 사용자가 생성하고 싶은데로 마음 껏 생성하고 삭제할 수 있지만 운영환경에서 토픽을 마음데로 생성하고 삭제하는 건 쉽지 않은 문제다. 또 토픽 생성에 대한 가이드나 제한이 없기때문에 개발자 필요에 따라 생성하게되며 무분별하게 생성된 토픽은 운영환경에서 상태 이슈를 만든다.

처음 카프카를 접했을 때 동기 서비스 개발에만 익숙했기 때문에 토픽을 생성할 때 비즈니스 기준으로 생성했다. 주문 시스템을 예로 들자면, 
- 주문 생성 토픽
- 주문 취소 토픽
- 수취인 주소 변경 토픽

와 같이 주문에 대한 새로운 비즈니스 생길 때 마다 새로운 토픽을 생성했다. 
개발할 때는 이게 어떤 이슈를 발생시키는지 알 수 없다. 개발할 때 마다 1초에 몇 천건의 주문을 한번에 처리하는 테스트를 진행하지는 않으니까.

한 주문의 주문의 라이프 사이클의 아래와 같다면
1. 주문 생성
2. 주문 취소

두 개의 토픽으로 주문의 이벤트를 처리할 경우 어떤 이슈가 발생할 수 있을까?

토픽이 다르다는 건 프로듀서가 발행하는 메시지가 저장되는 위치가 다르다는 의미이고
또 메시지를 처리하는 컨슈머가 다르다는 의미이기도 하다.

주문의 상태가 정상적이라면 주문이 생성되고 난 후에 취소가 이루어져야 한다.
토픽이 다르기 때문에 프로듀서는 주문 생성 시 주문 생성 토픽에 주문 취소 시 주문 취소 토픽에 각각 메시지를 발행하게 되는데 일반적인 상황에서는 주문 생성과 취소에 시간차가 있기 때문에 정상적으로 동작한다.

그런데 특정일에 주문이 폭등하여 주문 생성 토픽에서 처리해야할 메시지가 1000건이었고, 마지막 주문의 취소가 들어와서 주문 취소 토픽에는 1건의 메시지가 발행되었다.

주문 생성 토픽의 마지막 메시지가 아직 처리되기 직전이었기 때문에 생성 보다 먼저 처리된 주문 취소 토픽에서는 취소 대상인 주문을 찾을 수 없다는 에러가 발생할 것이다.

상태를 가지고 있는 어떤 대상에 대한 이벤트를 처리할 때 그 이 벤트마다 다른 토픽을 갖고 있게 되면 이 이벤트에 대한 순차적인 처리를 보장할 수 없게 된다.

개발할 당시에는 주문을 하고 취소를 하는 행위가 시간차를 두고 또 적은양의 트래픽으로 테스트하기 때문에 발견하기 쉽지 않다. 하지만 많은 데이터를 처리하는 운영 환경으로 넘어가면 이 이슈는 적어도 한 번 이상은 발생하게 된다.

그 때 마다 개발자가 데이터를 보정해야 한다면? 비즈니스가 복잡해져서 보정이 필요한 대상이 갈수록 많아진다면? 

애초에 주문이라는 토픽 한 개만 있다면, 파티션 키가 주문번호였다면 주문 생성과 취소는 하나의 파티션으로 들어가 순서데로 처리되지 않았을까?